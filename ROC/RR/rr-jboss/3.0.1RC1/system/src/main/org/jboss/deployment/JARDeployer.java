/***************************************
 *                                     *
 *  JBoss: The OpenSource J2EE WebOS   *
 *                                     *
 *  Distributable under LGPL license.  *
 *  See terms of license at gnu.org.   *
 *                                     *
 ***************************************/

package org.jboss.deployment;

import java.io.File;
import java.io.FileFilter;
import java.net.JarURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLClassLoader;
import java.util.Enumeration;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

import javax.management.MBeanServer;
import javax.management.ObjectName;

import org.jboss.system.ServiceMBeanSupport;

/**
 * This deployer exists to prevent deployment of packages whose deployers are not yet
 * deployed.  It will accept only jar/zip format files or directories that don't 
 * have a META-INF directory, or if they do, don't have any .xml files there.  It
 * assumes any package with a META-INF/*.xml file needs a specialized deployer.
 *
 * JARDeployerMBean.java is generated by XDoclet.
 *
 * @todo find a way to scan just the META-INF files, not the whole jar.
 *
 * Created: Mon Mar  4 12:58:19 2002
 *
 * @author <a href="mailto:d_jencks@users.sourceforge.net">David Jencks</a>
 * @version
 *
 * @jmx:mbean name="jboss.system:service=JARDeployer"
 *            extends="org.jboss.deployment.SubDeployerMBean"
 */

public class JARDeployer
   extends SubDeployerSupport
   implements JARDeployerMBean
{
   // ServiceMBeanSupport methods

   protected ObjectName getObjectName(MBeanServer server, ObjectName name)
      throws javax.management.MalformedObjectNameException
   {
      return OBJECT_NAME;
   }
   
   protected void stopService()
   {
      // This can't be run right now since the JARDeployer is started before the MainDeployer, 
      // so the MainDeployer is stopped first... so the JARDeployer can't unregister.

      // super.stopService();
   }

   // SubDeployer implementation

   /**
    * The <code>accepts</code> method is called by MainDeployer to 
    * determine which deployer is suitable for a DeploymentInfo.
    *
    * @todo find a way to scan just the META-INF files, not the whole jar.
    *
    * @param sdi a <code>DeploymentInfo</code> value
    * @return a <code>boolean</code> value
    */
   public boolean accepts(DeploymentInfo di)
   {
      boolean trace = log.isTraceEnabled();
      
      try 
      {
         if (di.isXML) 
         {
            return false;  
         } // end of if ()
         
         URL wdDir = di.localCl.findResource("WEB-INF/");
         if (wdDir != null) 
         {
            return false;
         } // end of if ()
         
         // Since a META-INF directory exists within rt.jar, we can't just do a 
         // getResource (it will always return rt.jar's version).
         // The method we want is findResource, but it is marked protected in
         // ClassLoader.  Fortunately, URLClassLoader exposes it which makes
         // this hack possible.  Anybody have a better way to check a URL
         // for the existance of a META-INF??
         URL ddDir;
         try 
         {
            ddDir = di.localCl.findResource("META-INF/");
            if (ddDir == null) 
            {
               log.debug("no META-INF or WEB-INF found, this is for us");
               return true;
            }
         } 
         catch (ClassCastException e) 
         {
             // assume there is a META-INF...
             ddDir = new URL(di.url, "META-INF/");
         }
            
         if (ddDir.getProtocol().equals("file")) 
         {
            log.debug("file protocol");
            File file = new File(ddDir.getFile());
            if (!file.exists()) 
            {
               //this is redundant, isn't it?
               log.warn("file protocol, but file doesn't exist");
               return true;
            } // end of if ()
            File[] entries = file.listFiles(
               new FileFilter() {
                  public boolean accept(File pathname)
                  {
                     return pathname.toString().endsWith(".xml");
                  }
               });
            log.debug("file protocol, entries.length " + entries.length);
            return entries.length == 0;            
         } // end of if ()
         else if (ddDir.getProtocol().equals("jar") || ddDir.getProtocol().equals("njar")) 
         {
            log.trace("jar or njar protocol: " + ddDir.getProtocol());
            JarFile jarFile =null;
      
            try
            {
               URLConnection con = ddDir.openConnection();
               JarURLConnection jarConn = (JarURLConnection)con;
               jarFile = jarConn.getJarFile();
            }
            catch (Exception e)
            {
               log.warn("looking inside jar failed; ignoring", e);
               return false;
            }

            for (Enumeration e = jarFile.entries(); e.hasMoreElements();)
            {
               JarEntry entry = (JarEntry)e.nextElement();
               String name = entry.getName();
               if (trace) 
               {
                  log.trace("looking at entry: " + name);
               } // end of if ()
               
               if (name.startsWith("META-INF/") && name.endsWith(".xml")) 
               {
                  return false;
               } // end of if ()
            } // end of for
            log.debug("no xmls found");
            return true;
         } // end of if ()
         else
         {
            log.debug("unrecognized protocol");
         } // end of else

         return false;
      }
      catch (Exception e) 
      { 
         return false;
      }
   }
}
