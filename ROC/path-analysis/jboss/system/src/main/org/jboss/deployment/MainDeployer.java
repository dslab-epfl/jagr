/***************************************
 *                                     *
 *  JBoss: The OpenSource J2EE WebOS   *
 *                                     *
 *  Distributable under LGPL license.  *
 *  See terms of license at gnu.org.   *
 *                                     *
 ***************************************/

package org.jboss.deployment;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import javax.management.JMException;
import javax.management.MBeanServer;
import javax.management.MalformedObjectNameException;
import javax.management.Notification;
import javax.management.ObjectName;
import org.jboss.system.ServiceMBeanSupport;
import org.jboss.system.server.ServerConfig;
import org.jboss.system.server.ServerConfigLocator;
import org.jboss.util.Counter;
import org.jboss.util.file.JarUtils;
import org.jboss.util.jmx.JMXExceptionDecoder;
import org.jboss.util.stream.Streams;

/**
 * The main/primary component for deployment.
 * 
 * <p>MainDeployerMBean is generated by xdoclet.
 *
 * @author <a href="mailto:marc.fleury@jboss.org">Marc Fleury</a>
 * @author <a href="mailto:scott.stark@jboss.org">Scott Stark</a>
 * @author <a href="mailto:d_jencks@users.sourceforge.net">David Jencks</a>
 * @version $Revision: 1.1.1.1 $
 *
 * @jmx:mbean name="jboss.system:service=MainDeployer"
 *            extends="org.jboss.system.ServiceMBean, org.jboss.deployment.DeployerMBean"
 */
public class MainDeployer
   extends ServiceMBeanSupport
   implements Deployer, MainDeployerMBean
{

   /**
    * The variable <code>serviceController</code> is used by the 
    * checkIncompleteDeployments method to ask for lists of mbeans 
    * with deployment problems.
    */
   private final ObjectName serviceController;

   /** Deployers **/
   private final LinkedList deployers = new LinkedList();
   
   /** A Map of URL -> DeploymentInfo */
   private final Map deploymentMap = new HashMap();

   /** A list of all deployments that have deployers. */
   private final List deploymentList = new ArrayList();

   /** A list of all deployments that do not have deployers. */
   private final List waitingDeployments = new ArrayList();

   /** an increment for tmp files **/
   private final Counter id = Counter.makeSynchronized(new Counter(0));
   
   /** A helper for sorting deployment URLs. */
   private final Comparator sorter = new DeploymentSorter();
   
   /** A helper for sorting deploymentInfos */
   private final Comparator infoSorter = new DeploymentInfoComparator(sorter);

   /** Should local copies be made of resources on the local file system */
   private boolean copyFiles = true;

   /** The temporary directory for deployments. */
   private File tempDir;

   /** The string naming the tempDir **/
   private String tempDirString;
   /** The string naming the local home dir for the server */
   private String homeDirString;

   /**
    * Holds the native library <em>prefix</em> for this system.
    * Determined by examining the result of System.mapLibraryName("XxX").
    */
   private String nativePrefix;

   /**
    * Holds the native library <em>suffix</em> for this system.
    * Determined by examining the result of System.mapLibraryName("XxX").
    */
   private String nativeSuffix;

   /**
    * Explict no-args contsructor for JMX.
    */
   public MainDeployer(final ObjectName serviceController)
   {
      super();
      this.serviceController = serviceController;
      // Is there a better place to obtain startup information?
      String localCopy = System.getProperty("jboss.deploy.localcopy");
      if (localCopy != null && (
          localCopy.equalsIgnoreCase("false") ||
          localCopy.equalsIgnoreCase("no") ||
          localCopy.equalsIgnoreCase("off")))
      {
         log.debug("Disabling local copies of file: urls");
         copyFiles = false;
      }
   }

   /**
    * The <code>listDeployed</code> method returns a collection of DeploymemtInfo
    * objects for the currently deployed packages.
    *
    * @return a <code>Collection</code> value
    * @jmx:managed-operation
    */
   public Collection listDeployed()
   {
      log.info("deployment list string: " + deploymentList);
      synchronized (deploymentList)
      {
         return new ArrayList(deploymentList);
      }
   }

   /**
    * Describe <code>listDeployedAsString</code> method here.
    *
    * @return a <code>String</code> value
    * @jmx:managed-operation
    */
   public String listDeployedAsString()
   {
      return "<pre>" + listDeployed() + "</pre>";
   }

   /**
    * The <code>listIncompletelyDeployed</code> method returns a list of packages that have
    * not deployed completely. The toString method will include any exception in the status
    * field.
    *
    * @return a <code>Collection</code> value
    * @jmx:managed-operation
    */
   public Collection listIncompletelyDeployed()
   {
      List id = new ArrayList();
      for (Iterator i = deploymentList.iterator(); i.hasNext();)
      {
         DeploymentInfo di = (DeploymentInfo)i.next();
         if (!"Deployed".equals(di.status) && !"Starting".equals(di.status)) 
         {
            id.add(di);
         } // end of if ()
         
      } // end of for ()
      return id;
   }
   
   /**
    * The <code>listWaitingForDeployer</code> method returns a collection
    * of the packages that currently have no identified deployer.
    *
    * @return a <code>Collection</code> value
    * @jmx:managed-operation
    */
   public Collection listWaitingForDeployer()
   {
      synchronized (waitingDeployments)
      {
         return new ArrayList(waitingDeployments);
      }
   }
   
   /**
    * The <code>addDeployer</code> method registers a deployer with the main deployer.
    * Any waiting packages are tested to see if the new deployer will deploy them.
    *
    * @param deployer a <code>SubDeployer</code> value
    * @jmx:managed-operation
    */
   public void addDeployer(final SubDeployer deployer) 
   {
      log.info("Adding deployer: " + deployer);
      synchronized(deployers)
      {
         deployers.addFirst(deployer); 
      }
      synchronized (waitingDeployments)
      {
         List copy = new ArrayList(waitingDeployments);
         waitingDeployments.clear();
         for (Iterator i = copy.iterator(); i.hasNext();)
         {
            DeploymentInfo di = (DeploymentInfo)i.next();
            log.debug("trying to deploy with new deployer: " + di.shortName);
            try 
            {
               deploy(di);
            }
            catch (DeploymentException e)
            {
               log.error("DeploymentException while trying to deploy a package with a new deployer", e);
            } // end of try-catch
            
         } // end of for ()         
      }
   }

   /**
    * The <code>removeDeployer</code> method unregisters a deployer with the MainDeployer.
    * Deployed packages deployed with this deployer are undeployed.
    *
    * @param deployer a <code>SubDeployer</code> value
    * @jmx:managed-operation
    */
   public void removeDeployer(final SubDeployer deployer) 
   {
      log.info("Removing deployer: " + deployer);
      synchronized(deployers)
      {
         deployers.remove(deployer);
      }
      List copy = null;
      synchronized(deploymentList)
      {
         copy = new ArrayList(deploymentList);
      }
      for (Iterator i = copy.iterator(); i.hasNext(); )
      {
         DeploymentInfo di = (DeploymentInfo)i.next();
         if (di.deployer == deployer)
         {
            undeploy(di);
            di.deployer = null;
            synchronized (waitingDeployments)
            {
               waitingDeployments.add(di);
            }
         }
      }
   }

   /**
    * The <code>listDeployers</code> method returns a collection of ObjectNames of
    * deployers registered with the MainDeployer.
    *
    * @return a <code>Collection</code> value
    * @jmx:managed-operation
    */
   public Collection listDeployers()
   {
      synchronized(deployers)
      {
         return new ArrayList(deployers);
      }
   }
   
   
   // ServiceMBeanSupport overrides ---------------------------------
   
   protected ObjectName getObjectName(MBeanServer server, ObjectName name)
      throws MalformedObjectNameException
   {
      return name == null ? OBJECT_NAME : name;
   }

   /**
    * The <code>createService</code> method is one of the ServiceMBean lifecyle operations.
    * (no jmx tag needed from superinterface)
    * @exception Exception if an error occurs
    */
   protected void createService() throws Exception
   {
      // watch the deploy directory, it is a set so multiple adds 
      // (start/stop) only one entry is present
      // get the temporary directory to use

      ServerConfig config = ServerConfigLocator.locate();
      homeDirString = config.getHomeDir().toURL().toString();
      File basedir = config.getServerTempDir();
      tempDir = new File(basedir, "deploy");

      // used in isWatched
      tempDirString = tempDir.toURL().toString(); 
   }
   
   /**
    * The <code>shutdown</code> method undeploys all deployed packages in 
    * reverse order of their deployement.
    *
    * @jmx:managed-operation
    */
   public void shutdown()
   {
      // if we shutdown in the middle of a scan, it still might be possible that we try to redeploy 
      // things we are busy killing...
      int deployCounter = 0;

      // undeploy everything in sight
      List copyDeployments = new ArrayList(deploymentList);
      for (ListIterator i = copyDeployments.listIterator(copyDeployments.size()); i.hasPrevious(); )
      {
         try 
         {
            undeploy((DeploymentInfo)i.previous(), true);
            deployCounter++;
         }
         catch (Exception e)
         {
            log.info("exception trying to undeploy during shutdown", e);
         }
         
      }

      log.info("Undeployed " + deployCounter + " deployed packages");
   }


   /**
    * Describe <code>redeploy</code> method here.
    *
    * @param urlSpec a <code>String</code> value
    * @exception DeploymentException if an error occurs
    * @exception MalformedURLException if an error occurs
    * @jmx:managed-operation
    */
   public void redeploy(String urlspec)
      throws DeploymentException, MalformedURLException
   {
      redeploy(new URL(urlspec));
   }

   /**
    * Describe <code>redeploy</code> method here.
    *
    * @param url an <code>URL</code> value
    * @exception DeploymentException if an error occurs
    * @jmx:managed-operation
    */
   public void redeploy(URL url) throws DeploymentException
   {
      DeploymentInfo sdi = getDeployment(url);
      if (sdi!= null)
      {
         redeploy(sdi);
      }
      else
      {
         deploy(url);
      } // end of else
   }

   /**
    * Describe <code>redeploy</code> method here.
    *
    * @param sdi a <code>DeploymentInfo</code> value
    * @exception DeploymentException if an error occurs
    * @jmx:managed-operation
    */
   public void redeploy(DeploymentInfo sdi) throws DeploymentException
   {
      try 
      {
         undeploy(sdi);
      }
      catch (Throwable t)
      {
         log.info("Throwable from undeployment attempt: ", t);
      } // end of try-catch
      deploy(sdi);
   }

   
   /**
    * The <code>undeploy</code> method  undeploys a package identified by a URL
    *
    * @param url an <code>URL</code> value
    * @jmx:managed-operation
    */
   public void undeploy(URL url) throws DeploymentException
   {
      DeploymentInfo sdi = getDeployment(url);
      if (sdi!= null)
      {
         undeploy(sdi);
      }
   }

   /**
    * The <code>undeploy</code> method undeploys a package identified by a string
    * representation of a URL.
    *
    * @param urlspec a <code>String</code> value
    * @exception MalformedURLException if an error occurs
    * @jmx:managed-operation
    */
   public void undeploy(String urlspec)
      throws DeploymentException, MalformedURLException
   {
      undeploy(new URL(urlspec));
   }
   
   /**
    * The <code>undeploy</code> method undeploys a package represented by a 
    * DeploymentInfo object.
    *
    * @param di a <code>DeploymentInfo</code> value
    * @jmx:managed-operation
    */
   public void undeploy(DeploymentInfo di)
   {
      undeploy(di, false);
   }
   protected void undeploy(DeploymentInfo di, boolean isShutdown)
   {
      log.info("Undeploying "+di.url);
      stop(di);
      destroy(di);
      String type = (isShutdown) ? "UndeploymentShutdown" : "Undeployment";
      //AS Test if JMX Notifications can be used to trigger the FarmMemberService
      Notification lNotification = new Notification(
         type,
         this,
         0L
      );
      lNotification.setUserData( di.url );
      sendNotification( lNotification );
   }

   /**
    * The <code>stop</code> method  is the first internal step of undeployment
    *
    * @param di a <code>DeploymentInfo</code> value
    */
   private void stop(DeploymentInfo di)
   {
      // First stop this deployment itself
      try 
      { 
         // Tell the respective deployer to undeploy this one
         if (di.deployer != null)
         {
            di.deployer.stop(di); 
         }
      }
      catch (Throwable t)
      {
         log.error("Undeployment failed: " + di.url, t); 
      }
      // Then stop all sub-deployments
      for (Iterator subs = di.subDeployments.iterator(); subs.hasNext();)
      {
         DeploymentInfo sub = (DeploymentInfo) subs.next();
         log.debug("Stopping sub deployment: "+sub.url);
         stop(sub);      
      }

   }

   /**
    * The <code>destroy</code> method is the second and final internal undeployment step.
    *
    * @param di a <code>DeploymentInfo</code> value
    */
   private void destroy(DeploymentInfo di)
   {
      // First destroy the deployment itself
      try 
      { 
         // Tell the respective deployer to undeploy this one
         if (di.deployer != null)
         {
            di.deployer.destroy(di); 
         }
      }
      catch (Throwable t)
      {
         log.error("Undeployment failed: " + di.url, t); 
      }

      // Then destroy all sub-deployments
      for (Iterator subs = di.subDeployments.iterator(); subs.hasNext();)
      {
         DeploymentInfo sub = (DeploymentInfo) subs.next();
         log.debug("Destroying sub deployment: "+sub.url);
         destroy(sub);      
      }

      try
      {
         // remove from local maps
         synchronized (deploymentList)
         {
            deploymentMap.remove(di.url);
            if (deploymentList.lastIndexOf(di) != -1)
            {
               deploymentList.remove(deploymentList.lastIndexOf(di));
            }
         }
         synchronized (waitingDeployments)
         {
            waitingDeployments.remove(di);
         }
         // Nuke my stuff, this includes the class loader
         di.cleanup(log);
         
         log.info("Undeployed "+di.url);
      
      }
      catch (Throwable t)
      {
         log.error("Undeployment cleanup failed: " + di.url, t); 
      }
   }
   
   /**
    * The <code>deploy</code> method deploys a package identified by a 
    * string representation of a URL.
    *
    * @param urlspec a <code>String</code> value
    * @exception MalformedURLException if an error occurs
    * @jmx:managed-operation
    */
   public void deploy(String urlspec)
      throws DeploymentException, MalformedURLException
   {
      URL url;
      try
      {
         url = new URL(urlspec);
      }
      catch (MalformedURLException e)
      {
         File file = new File(urlspec);
         url = file.toURL();
      }

      deploy(url);
   }

   /**
    * The <code>deploy</code> method deploys a package identified by a URL
    *
    * @param url an <code>URL</code> value
    * @jmx:managed-operation
    */
   public void deploy(URL url) throws DeploymentException
   {
      DeploymentInfo sdi = getDeployment(url);
      // if it does not exist create a new deployment
      if (sdi == null)
      {
         sdi = new DeploymentInfo(url, null, getServer());
         deploy(sdi);
      }
      if( sdi.state != DeploymentState.STARTED )
         checkIncompleteDeployments();
   }

   /**
    * The <code>deploy</code> method deploys a package represented by a DeploymentInfo object.
    *
    * @param deployment a <code>DeploymentInfo</code> value
    * @exception DeploymentException if an error occurs
    * @jmx:managed-operation
    */
   public void deploy(DeploymentInfo deployment) 
      throws DeploymentException
   {      
      // If we are already deployed return
      if (isDeployed(deployment.url))
      {
         log.info("Package: " + deployment.url + " is already deployed");
         return;
      }
      log.info("Starting deployment of package: " + deployment.url);

      if ( init(deployment) )
      {
         //AS Test if JMX Notifications can be used to trigger the FarmMemberService
         Notification lNotification = new Notification(
            "Deployment",
            this,
            0L
         );
         lNotification.setUserData( deployment.url );
         sendNotification( lNotification );
         
         create(deployment);
         start(deployment);
         log.info("Deployed package: " + deployment.url);
      } // end of if ()
      else
      {
         log.info("Deployment of package: " + deployment.url + " is waiting for an appropriate deployer.");
      } // end of else
   }
   

   /**
    * The <code>init</code> method is the first internal deployment step.
    * The tasks are to copy the code if necessary, 
    * set up classloaders, and identify the deployer for the package.
    *
    * @param deployment a <code>DeploymentInfo</code> value
    * @throws DeploymentException if an error occurs
    */
   private boolean init(DeploymentInfo deployment) throws DeploymentException
   {
      // If we are already deployed return
      if (isDeployed(deployment.url))
      {
         log.info("Package: " + deployment.url + " is already deployed");
         return false;
      }
      log.debug("Starting deployment (init step) of package at: " + deployment.url);
      try 
      {
         // Create a local copy of that File, the sdi keeps track of the copy directory
         if (deployment.localUrl == null) 
         {
            makeLocalCopy(deployment);
            // initialize the unified classloaders for this deployment
            deployment.createClassLoaders();
         } // end of if ()

         // What deployer is able to deploy this file
         findDeployer(deployment);
         
         if(deployment.deployer == null)
         {
            deployment.state = DeploymentState.INIT_WAITING_DEPLOYER;
            log.info("deployment waiting for deployer: " + deployment.url);
            synchronized (waitingDeployments)
            {
               waitingDeployments.add(deployment);
            }
            return false;
         }
         deployment.state = DeploymentState.INIT_DEPLOYER;
         //we have the deployer, continue deployment.
         deployment.deployer.init(deployment); 
         deployment.state = DeploymentState.INITIALIZED;

         // Add the deployment to the map so we can detect circular deployments
         synchronized (deploymentList)
         {
            deploymentMap.put(deployment.url, deployment);
         }

         // create subdeployments as needed
         parseManifestLibraries(deployment);

         log.debug("found " + deployment.subDeployments.size() + " subpackages of " + deployment.url);
         // get sorted subDeployments
         ArrayList sortedSubs = new ArrayList(deployment.subDeployments);
         Collections.sort(sortedSubs, infoSorter);
         for (Iterator lt = sortedSubs.listIterator(); lt.hasNext();) 
         { 
            init((DeploymentInfo) lt.next());
         }
      }
      catch (DeploymentException e)
      {
         deployment.state = DeploymentState.FAILED;
         throw e;
      }
      catch (Exception e)
      {
         deployment.state = DeploymentState.FAILED;
         throw new DeploymentException("exception in init of " + deployment.url, e);
      }
      finally 
      {
         // whether you do it or not, for the autodeployer
         try
         {
            URL url = deployment.localUrl == null ? deployment.url : deployment.localUrl;

            long lastModified = url.openConnection().getLastModified();
            deployment.lastModified = lastModified;
            deployment.lastDeployed = System.currentTimeMillis();
         }
         catch (IOException ignore)
         {
            deployment.lastModified = System.currentTimeMillis();
            deployment.lastDeployed = System.currentTimeMillis();
         }

         synchronized (deploymentList)
         {
            // Do we watch it? Watch only urls outside our copy directory.
            if (!inLocalCopyDir(deployment.url)) 
            {
               deploymentList.add(deployment);
               log.debug("Watching new file: " + deployment.url);  
            }
         }
      }
      return true;
   }

   /**
    * The <code>create</code> method is the second internal deployment step.
    * It should set up all information not 
    * requiring other components.  for instance, the ejb Container is created,
    * and the proxy bound into jndi.
    *
    * @param deployment a <code>DeploymentInfo</code> value
    * @throws DeploymentException if an error occurs
    */
   private void create(DeploymentInfo deployment) throws DeploymentException
   {
      log.debug("create step for deployment " + deployment.url);
      try 
      {
         ArrayList sortedSubs = new ArrayList(deployment.subDeployments);
         Collections.sort(sortedSubs, infoSorter);
         for (Iterator lt = sortedSubs.listIterator(); lt.hasNext();) 
         { 
            create((DeploymentInfo) lt.next());
         }
         deployment.state = DeploymentState.CREATE_SUBDEPLOYMENTS;

         // Deploy this SDI, if it is a deployable type
         if (deployment.deployer != null)
         {
            deployment.state = DeploymentState.CREATE_DEPLOYER;
            deployment.deployer.create(deployment);
            // See if all mbeans are created...
            deployment.state = DeploymentState.CREATED;
            deployment.status="Created";
            log.debug("Done with create step of deploying " + deployment.shortName);
         }
         else
         {
            log.debug("Still no deployer for package in create step: "  + deployment.shortName);
         } // end of else
      }
      catch (Throwable t)
      {
         deployment.status = "Deployment FAILED reason: " + t.getMessage();
         deployment.state = DeploymentState.FAILED;
         if (t instanceof DeploymentException)
            throw (DeploymentException)t;
         throw new DeploymentException("Could not create deployment: " + deployment.url, t);
      }
   }

   /**
    * The <code>start</code> method is the third and final internal deployment step.
    * The purpose is to set up relationships between components.
    * for instance, ejb links are set up here.
    *
    * @param deployment a <code>DeploymentInfo</code> value
    * @throws DeploymentException if an error occurs
    */
   private void start(DeploymentInfo deployment) throws DeploymentException
   {
      deployment.status = "Starting";
      log.debug("Begin deployment start " + deployment.url);
      try 
      {
         ArrayList sortedSubs = new ArrayList(deployment.subDeployments);
         Collections.sort(sortedSubs, infoSorter);
         for (Iterator lt = sortedSubs.listIterator(); lt.hasNext();) 
         { 
            start((DeploymentInfo) lt.next());
         }
         deployment.state = DeploymentState.START_SUBDEPLOYMENTS;

         // Deploy this SDI, if it is a deployable type
         if (deployment.deployer != null)
         {
            deployment.state = DeploymentState.START_DEPLOYER;
            deployment.deployer.start(deployment);
            // See if all mbeans are started...
            Object[] args = {deployment, DeploymentState.STARTED};
            String[] sig = {"org.jboss.deployment.DeploymentInfo",
               "org.jboss.deployment.DeploymentState"};
            server.invoke(serviceController, "validateDeploymentState",args, sig);
            deployment.status="Deployed";
            log.debug("End deployment start on package: "+ deployment.shortName);
         }
         else
         {
            log.debug("Still no deployer for package in start step: "  + deployment.shortName);
         } // end of else
      }
      catch (Throwable t)
      {
         deployment.state = DeploymentState.FAILED;
         deployment.status = "Deployment FAILED reason: " + t.getMessage();
         if (t instanceof DeploymentException)
            throw (DeploymentException)t;
         throw new DeploymentException("Could not create deployment: " + deployment.url, t);
      }
   }

   /**
    * The <code>findDeployer</code> method attempts to find a deployer for the DeploymentInfo
    * supplied as a parameter. 
    *
    * @param sdi a <code>DeploymentInfo</code> value
    */
   private void findDeployer(DeploymentInfo sdi) 
   {
      // Defensive
      sdi.deployer = null;
      
      //
      // To deploy directories of beans one should just name the directory
      // mybean.ear/bla...bla, so that the directory gets picked up by the right deployer
      //
      synchronized(deployers)
      {
         for (Iterator iterator = deployers.iterator(); iterator.hasNext(); )
         {
            SubDeployer deployer = (SubDeployer) iterator.next();
            if (deployer.accepts(sdi))
            {
               sdi.deployer = deployer;
               log.debug("using deployer "+deployer);
               return;
            }
         }
      }
      log.debug("No deployer found for url: " + sdi.url);
   }

   /**
    * The <code>parseManifestLibraries</code> method looks into the manifest for classpath
    * goo, and tries to deploy referenced packages.
    *
    * @param sdi a <code>DeploymentInfo</code> value
    * @exception DeploymentException if an error occurs
    */
   private void parseManifestLibraries(DeploymentInfo sdi) throws DeploymentException
   {
      String classPath = null;
      
      Manifest mf = sdi.getManifest();
      
      if( mf != null )
      {
         Attributes mainAttributes = mf.getMainAttributes();
         classPath = mainAttributes.getValue(Attributes.Name.CLASS_PATH);
      }
      
      if (classPath != null)
      {
         ArrayList tmp = new ArrayList();
         StringTokenizer st = new StringTokenizer(classPath);
         log.debug("resolveLibraries: "+classPath);

         while (st.hasMoreTokens())
         {
            URL lib = null;            
            String tk = st.nextToken();
            DeploymentInfo sub = null;
            log.debug("new manifest entry for sdi at "+sdi.shortName+" entry is "+tk);

            try
            {   
               if (sdi.isDirectory)
               {
                  File parentDir = new File(sdi.url.getPath()).getParentFile();
                  lib = new File(parentDir, tk).toURL();
               }
               else
               {
                  lib = new URL(sdi.url, tk);
               }

               // Only deploy this if it is not already being deployed
               if ( deploymentMap.containsKey(lib) == false )
               {
                  // Try having it as a full subdeployment
                  sub = new DeploymentInfo(lib, sdi, getServer());
                  deploy(sub);
               }
            }
            catch (Exception ignore)
            { 
               log.warn("The manifest entry in "+sdi.url+" references URL "+lib+ 
                  " which could not be opened, entry ignored");
            } 
         }
      }
   }

   /** 
    * Downloads the jar file or directory the src URL points to.
    * In case of directory it becomes packed to a jar file.
    *
    * @return a File object representing the downloaded module
    * @throws DeploymentException
    */
   private void makeLocalCopy(DeploymentInfo sdi) 
      throws DeploymentException
   {
      try 
      {   
         if (sdi.url.getProtocol().equals("file") && (!copyFiles || sdi.isDirectory))
         {
            // If local copies have been disabled, do nothing
            // TODO add support for Directory copying over            
            sdi.localUrl = sdi.url;
            return;
         }
         // Are we already in the localCopyDir?
         else if (inLocalCopyDir(sdi.url))
         {
            sdi.localUrl = sdi.url;
            return;
         }
         else
         {
            /* Strip any prefix matching homeDirString to avoid execessively
             long file names under the tempDir
            */
            String sdiPath = sdi.url.toString();
            if( sdiPath.startsWith(this.homeDirString) )
               sdiPath = sdiPath.substring(homeDirString.length());
            else
               sdiPath = sdi.url.getFile();
            // remove windows : from c:\nowhere.  There must be a better way to do this...
            StringBuffer path = new StringBuffer(sdiPath);
            for (int i = path.length() - 1; i > -1; i--)
            {
               if (path.charAt(i) == ':')
               {
                  path.deleteCharAt(i);
               }
            }

            String shortName = DeploymentInfo.getShortName(path.toString());
            path.append("/").append(id.increment()).append(".").append(shortName);
            String fullPath = path.toString();
            sdi.localUrl =  new File(tempDir, fullPath).toURL();
            copy(sdi.url, sdi.localUrl);
         }
      }
      catch (Exception e)
      {
         log.error("Could not make local copy for " + sdi.url, e);
      }
   }

   private boolean inLocalCopyDir(URL url)
   {
      int i = 0;
      String urlTest = url.toString();
      if( urlTest.startsWith("jar:") )
         i = 4;
      
      return urlTest.startsWith(tempDirString, i); 
   }
   
   protected void copy(URL _src, URL _dest) throws IOException
   {
      if (!_dest.getProtocol().equals("file"))
         throw new IllegalArgumentException
            ("only file: protocol is allowed as destination!");
      
      File file = new File(_dest.getFile());
      File dir = file.getParentFile();
      if (!dir.exists())
      {
         dir.mkdirs();
      }

      if (_src.getProtocol().equals("file"))
      {
         File srcFile = new File(_src.getFile());
         if (srcFile.isDirectory())
         {
            log.debug("Making zip copy of: " + srcFile);
            // make a jar archive of the directory
            OutputStream out = new BufferedOutputStream(new FileOutputStream(file));
            JarUtils.jar(out, srcFile.listFiles());
            out.close();
            return;
         }
      }
      InputStream in = new BufferedInputStream(_src.openStream());
      OutputStream out = new BufferedOutputStream(new FileOutputStream(file));
      Streams.copy(in, out);
      out.flush();
      out.close();
      in.close();
   }
   
   /**
    * The <code>isDeployed</code> method tells you if a package identified by a string
    * representation of a URL is currently deployed.
    *
    * @param url a <code>String</code> value
    * @return a <code>boolean</code> value
    * @exception MalformedURLException if an error occurs
    * @jmx:managed-operation
    */
   public boolean isDeployed(String url) 
      throws MalformedURLException
   {
      return isDeployed(new URL(url));
   }

   /**
    * The <code>isDeployed</code> method tells you if a packaged identified by
    * a URL is deployed.
    * @todo Implement type-safe enum for di.status.
    * @param url an <code>URL</code> value
    * @return a <code>boolean</code> value
    * @jmx:managed-operation
    */
   public boolean isDeployed(URL url)
   {
      DeploymentInfo di = getDeployment(url);
      if (di == null) 
      {
         return false;
      } // end of if ()
      return di.state == DeploymentState.STARTED;
   }

   /**
    * The <code>getDeployment</code> method returns the DeploymentInfo
    * object for the URL supplied.
    *
    * @param url an <code>URL</code> value
    * @return a <code>DeploymentInfo</code> value
    * @jmx:managed-operation
    */
   public DeploymentInfo getDeployment(URL url)  
   { 
      synchronized (deploymentList)
      {
         return (DeploymentInfo) deploymentMap.get(url); 
      }
   }
   
   /**
    * The <code>getWatchUrl</code> method returns the URL that, when modified,
    * indicates that a redeploy is needed.
    *
    * @param url an <code>URL</code> value
    * @return a <code>URL</code> value
    * @jmx:managed-operation
    */
   public URL getWatchUrl(URL url)  
   {
      DeploymentInfo info = getDeployment(url);
      return info == null ? null : info.watch;
   }

   /** Check the current deployment states and generate a IncompleteDeploymentException
    * if there are mbeans waiting for depedencies.
    * @exception IncompleteDeploymentException
    * @jmx:managed-operation
    */
   public void checkIncompleteDeployments() throws DeploymentException
   {
      try 
      {
         Collection waitingForClasses = (Collection)server.invoke(serviceController,
                                                      "listWaitingMBeans",
                                                      new Object[] {},
                                                      new String[] {});
         Collection waitingForDepends = (Collection)server.invoke(serviceController,
                                                      "listIncompletelyDeployed",
                                                      new Object[] {},
                                                      new String[] {});

         IncompleteDeploymentException ide = new IncompleteDeploymentException(
            waitingForClasses,
            waitingForDepends,
            listIncompletelyDeployed(),
            listWaitingForDeployer());
         if (!ide.isEmpty()) 
         {
            throw ide;
         } // end of if ()
      }
      catch (JMException jme)
      {
         throw new DeploymentException(JMXExceptionDecoder.decode(jme));
      } // end of try-catch
   }

}
