package roc.loadgen.http;

import java.net.URL;
import java.net.URLConnection;
import java.util.Map;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.text.SimpleDateFormat;
import java.io.IOException;
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.log4j.Logger;


/**
 * The CookieManager sends and retreives cookies to/from an HTTP
 * server via a URLConnection. It keeps a running accumulation of all
 * the cookies sent in its private "cookie jar", and arranges to send
 * all such cookies when "setCookiesToSend" is called.
 *
 * Note: The CookieManager handles cookie expiration times, but does NOT currently handle
 * cookie filtering based on domain or any other "complex" cookie management functions.
 *
 * @author Shinichi Kawamoto  (This code is based on Greg's Cookie Manager)
 */
public class HttpCookieManager
{
    private static Logger log = Logger.getLogger("http.HttpCookieManager");

    private HashMap cookieJar;

    /**
     * Create a new cookie manager, associated with the UserSession.
     * @param sess The associated UserSession, which may be used for logging.
     */
    public HttpCookieManager()
    {
	cookieJar = new HashMap();
    }


    /**
     * Empty my cookie jar. Removes all the cookies I was managing.
     */
    public void emptyCookieJar()
    {
	cookieJar.clear();
	log.debug("discard all cookies");
    }

    /**
     * Retrieve the cookies sent by the HTTP server, and store them 
     * in cookie jar. 
     *
     * @param response Http response 
     */
    public void getCookies(HttpResponse response)
    {
	Map httpHeader = response.getHeaders();

	Object cookies = httpHeader.get("Set-Cookie");
	if ( cookies != null ) {
	    Iterator cookieIter = ((Collection)cookies).iterator();
	    try {
		while( cookieIter.hasNext() ) {
		    Cookie cookie = new Cookie((String)cookieIter.next());
		    cookieJar.put(cookie.Name, cookie);
		    log.debug("COOKIE: " + cookie.Name + "=" + cookie);
		}

		log.debug("Received cookies: "+cookieJar.values());

	    } catch (java.text.ParseException e) {
		log.error("Error parsing cookie from header returned from HTTP header: " + e.toString());
	    }
	}
    }

    /**
     * Set all the stored cookies in cookie jar to http request
     *
     * @param request  Http request 
     */

    public void setCookies(HttpRequest request)
    {
	if (cookieJar.size() > 0) {
	    Map header = request.getHeaders();
	    if ( header == null ) {
		header = new HashMap();
	    }
	    String cookies = generateCookieHeader();

	    log.debug("Inserting cookie(s): "+cookies);

	    header.put("Cookie", cookies);
	    request.setHeaders(header);
	}
    }


    /**
     * Generate the string representing all the cookies in cookie
     * jar; this String is in standard HTTP header format for cookies, so
     * it will be understood by an HTTP server. Expired cookies are
     * not included in this string.
     *
     * @returns A string representing all the unexpired cookies I am managing. 
     */
    private String generateCookieHeader() {
        String cookieLine = "";
	Date currentDate = null;

        Iterator iter = cookieJar.keySet().iterator();
        while (iter.hasNext()) {
            String key = (String)iter.next();
	    Cookie c = (Cookie)cookieJar.get(key);

	    if (c.Expiration != null) {
		// Check to see if cookie has expired
		if (currentDate == null) {
		    currentDate = new Date();
		}

		if (currentDate.compareTo(c.Expiration) > 0) {
		    log.debug("Cookie " + c.Name + " has expired");
		    c = null;
		}		
	    }
	    if (c != null) {		
		cookieLine += c.Name + "=" + c.Value;
		if (iter.hasNext()) {
		    cookieLine += "; ";
		}
	    }
	}

        return cookieLine;
    }

    // inner class

    /**
     * Represents a (simplified) HTTP cookie. This code is based on 
     *  Greg's edu.rice.rubis.client.Cookie.java.
     *
     * @author Shinichi Kawamoto, Stanford Unviersity
     */
    public class Cookie {
	/** The name (key) of the Cookie. */
	public String    Name;
	/** The value of the Cookie. */
	public String    Value;
	/** The cookie's expiration date */
	public Date      Expiration;

	/**
	 * Create a cookie with the given name, value and expiration.
	 *
	 * @param name The name (key) of the cookie 
	 * @param value The cookie's String value. 
	 * @param expiration When the cookie expires. If null, the cookie does not expire.
	 */
	public Cookie(String name, String value, Date expiration)
	{
	    this.Name = name;
	    this.Value = value;
	    this.Expiration = expiration;
	}

	/** 
	 * Create a Cookie from a text representation of a Cookie 
	 *  as generated by an HTTP server.
	 *
	 * @param cookieString Text representation of the cookie
	 */
	public Cookie(String cookieString) throws java.text.ParseException
	{
	    String fields[] = cookieString.split(";");
	    int eqlIdx = fields[0].indexOf("=");
	    
	    // First field is cookie's name and value
	    this.Name = fields[0].substring(0, eqlIdx);
	    this.Value = fields[0].substring(eqlIdx + 1);
	
	    // If expiration date is specified, use it.
	    this.Expiration = null;
	    for (int i = 1; i < fields.length; i++) {
		if (fields[i].indexOf("xpires") != -1) {
		    SimpleDateFormat df = new SimpleDateFormat("\"E, dd MMM yyyy HH:mm:ss Z\"");
		    eqlIdx = fields[i].indexOf("=");
		    String expireString = fields[i].substring(eqlIdx + 1);
		    this.Expiration = df.parse(expireString);
		}
	    }
	}
	
	public String toString(){
	    return "["+Name+"="+Value+","+Expiration+"]";
	}
    }
}
