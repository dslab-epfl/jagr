/*
 * JBoss, the OpenSource J2EE webOS
 *
 * Distributable under LGPL license.
 * See terms of license at gnu.org.
 */

package org.jboss.resource.adapter.jdbc.local;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;


/**
 * LocalStatement.java
 *
 *
 * Created: Sat Apr 20 14:29:19 2002
 *
 * @author <a href="mailto:d_jencks@users.sourceforge.net">David Jencks</a>
 * @version
 */

public class LocalStatement 
   implements Statement 
{

   private final LocalConnection lc;
   private final Statement s;


   public LocalStatement(final LocalConnection lc, Statement s) 
   {
      this.lc = lc;
      this.s = s;
   }
   // implementation of java.sql.Statement interface

   /**
    *
    * @exception java.sql.SQLException <description>
    */
   public void close() throws SQLException
   {
      try 
      {
         s.close();
      }
      catch (SQLException e)
      {
         checkException(e);
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public boolean execute(String sql) throws SQLException
   {
      checkTransaction();
      try 
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////    5 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      boolean result = s.execute(sql);
	      reportTrace(sql,null);
	      return result;
	  }
	  //// ROC PINPOINT MIKECHEN EMK END ////
	  else{ 
	      return s.execute(sql);         
	  }
      }
      catch (SQLException e)
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////   3 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      reportTrace(sql, e);
	  }
	  //// ROC PINPOINT MIKECHEN EMK END   ////	  

         checkException(e);
         return false;
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @param param2 <description>
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public boolean execute(String sql, int autoGeneratedKeys) throws SQLException
   {
@JDK1.4START@
      checkTransaction();
      try 
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////  5 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      boolean result = s.execute(sql, autoGeneratedKeys );
	      reportTrace(sql,null);
	      return result;
	  }
	  //// ROC PINPOINT MIKECHEN EMK END ////
	  else {
	      return s.execute(sql, autoGeneratedKeys);         
	  }
      }
      catch (SQLException e)
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////    3 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      reportTrace(sql, e);
	  }
	  //// ROC PINPOINT MIKECHEN EMK END   ////	  
         checkException(e);
         return false;
      } // end of try-catch
@JDK1.4END@
@JDK1.3START@
   throw new SQLException("JDK1.4 method not available in JDK1.3");
@JDK1.3END@
   }

   /**
    *
    * @param param1 <description>
    * @param param2 <description>
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public boolean execute(String sql, int[] columnIndexes) throws SQLException
   {
@JDK1.4START@
      checkTransaction();
      try 
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////   5 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      boolean result = s.execute(sql, columnIndexes);
	      reportTrace(sql,null);
	      return result;
	  }
	  //// ROC PINPOINT MIKECHEN EMK END ////
	  else {
	      return s.execute(sql, columnIndexes);         
	  }
      }
      catch (SQLException e)
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////   3 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      reportTrace(sql, e);
	  }
	  //// ROC PINPOINT MIKECHEN EMK END   ////	  
         checkException(e);
         return false;
      } // end of try-catch
@JDK1.4END@
@JDK1.3START@
   throw new SQLException("JDK1.4 method not available in JDK1.3");
@JDK1.3END@
   }

   /**
    *
    * @param param1 <description>
    * @param param2 <description>
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public boolean execute(String sql, String[]columnNames ) throws SQLException
   {
@JDK1.4START@
      checkTransaction();
      try 
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////    5 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      boolean result = s.execute(sql, columnNames );
	      reportTrace(sql,null);
	      return result;
	  }
	  //// ROC PINPOINT MIKECHEN EMK END ////
	  else {
	      return s.execute(sql, columnNames);         
	  }
      }
      catch (SQLException e)
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////    3 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      reportTrace(sql, e);
	  }
	  //// ROC PINPOINT MIKECHEN EMK END   ////	  
         checkException(e);
         return false;
      } // end of try-catch
@JDK1.4END@
@JDK1.3START@
   throw new SQLException("JDK1.4 method not available in JDK1.3");
@JDK1.3END@
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public Connection getConnection() throws SQLException
   {
      return lc;
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public SQLWarning getWarnings() throws SQLException
   {
      try 
      {
         return s.getWarnings();
      }
      catch (SQLException e)
      {
         checkException(e);
         return null;
      } // end of try-catch
   }

   /**
    *
    * @exception java.sql.SQLException <description>
    */
   public void clearWarnings() throws SQLException
   {
      try 
      {
         s.clearWarnings();
      }
      catch (SQLException e)
      {
         checkException(e);
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public ResultSet executeQuery(String sql) throws SQLException
   {
      checkTransaction();
      try 
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////    5 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      ResultSet result = s.executeQuery(sql);
	      reportTrace(sql,null);
	      return result;
	  }
	  //// ROC PINPOINT MIKECHEN EMK END ////
	  else {
	      return s.executeQuery(sql);         
	  }
      }
      catch (SQLException e)
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////    3 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      reportTrace(sql, e);
	  }
	  //// ROC PINPOINT MIKECHEN EMK END   ////	  
         checkException(e);
         return null;
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int executeUpdate(String sql) throws SQLException
   {
      checkTransaction();
      try 
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////   5 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      int result = s.executeUpdate(sql);
	      reportTrace(sql,null);
	      return result;
	  }
	  //// ROC PINPOINT MIKECHEN EMK END ////
	  else {
	      return s.executeUpdate(sql);         
	  }
      }
      catch (SQLException e)
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////   3 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      reportTrace(sql, e);
	  }
	  //// ROC PINPOINT MIKECHEN EMK END   ////	  
         checkException(e);
         return 0;
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @param param2 <description>
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException
   {
@JDK1.4START@
      checkTransaction();
      try 
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////   5 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      int result = s.executeUpdate(sql,autoGeneratedKeys);
	      reportTrace(sql,null);
	      return result;
	  }
	  //// ROC PINPOINT MIKECHEN EMK END ////
	  else { 
	      return s.executeUpdate(sql, autoGeneratedKeys);         
	  }
      }
      catch (SQLException e)
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////    3 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      reportTrace(sql, e);
	  }
	  //// ROC PINPOINT MIKECHEN EMK END   ////	  
         checkException(e);
         return 0;
      } // end of try-catch
@JDK1.4END@
@JDK1.3START@
   throw new SQLException("JDK1.4 method not available in JDK1.3");
@JDK1.3END@
   }

   /**
    *
    * @param param1 <description>
    * @param param2 <description>
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int executeUpdate(String sql, int[] columnIndexes) throws SQLException
   {
@JDK1.4START@
      checkTransaction();
      try 
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////    5 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      int result = s.executeUpdate(sql, columnIndexes);
	      reportTrace(sql,null);
	      return result;
	  }
	  //// ROC PINPOINT MIKECHEN EMK END ////
	  else {
	      return s.executeUpdate(sql, columnIndexes);         
	  }
      }
      catch (SQLException e)
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////    3 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      reportTrace(sql, e);
	  }
	  //// ROC PINPOINT MIKECHEN EMK END   ////	  
         checkException(e);
         return 0;
      } // end of try-catch
@JDK1.4END@
@JDK1.3START@
   throw new SQLException("JDK1.4 method not available in JDK1.3");
@JDK1.3END@
   }

   /**
    *
    * @param param1 <description>
    * @param param2 <description>
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int executeUpdate(String sql, String[] columnNames) throws SQLException
   {
@JDK1.4START@
      checkTransaction();
      try 
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////   5 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      int result = s.executeUpdate(sql, columnNames );
	      reportTrace(sql,null);
	      return result;
	  }
	  //// ROC PINPOINT MIKECHEN EMK END ////
	  else {
	      return s.executeUpdate(sql, columnNames);         
	  }
      }
      catch (SQLException e)
      {
	  //// ROC PINPOINT MIKECHEN EMK BEGIN ////   3 LINES
	  if( roc.config.ROCConfig.ENABLE_PINPOINT &&
	      roc.config.ROCConfig.ENABLE_PINPOINT_TRACING_DB ) {
	      reportTrace(sql, e);
	  }
	  //// ROC PINPOINT MIKECHEN EMK END   ////	  
         checkException(e);
         return 0;
      } // end of try-catch
@JDK1.4END@
@JDK1.3START@
   throw new SQLException("JDK1.4 method not available in JDK1.3");
@JDK1.3END@
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int getMaxFieldSize() throws SQLException
   {
      try 
      {
         return s.getMaxFieldSize();
      }
      catch (SQLException e)
      {
         checkException(e);
         return 0;
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @exception java.sql.SQLException <description>
    */
   public void setMaxFieldSize(int max) throws SQLException
   {
      try 
      {
         s.setMaxFieldSize(max);
      }
      catch (SQLException e)
      {
         checkException(e);
      } // end of try-catch
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int getMaxRows() throws SQLException
   {
      try 
      {
         return s.getMaxRows();
      }
      catch (SQLException e)
      {
         checkException(e);
         return 0;
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @exception java.sql.SQLException <description>
    */
   public void setMaxRows(int max) throws SQLException
   {
      try 
      {
         s.setMaxRows(max);
      }
      catch (SQLException e)
      {
         checkException(e);
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @exception java.sql.SQLException <description>
    */
   public void setEscapeProcessing(boolean enable) throws SQLException
   {
      try 
      {
         s.setEscapeProcessing(enable);
      }
      catch (SQLException e)
      {
         checkException(e);
      } // end of try-catch
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int getQueryTimeout() throws SQLException
   {
      try 
      {
         return s.getQueryTimeout();
      }
      catch (SQLException e)
      {
         checkException(e);
         return 0;
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @exception java.sql.SQLException <description>
    */
   public void setQueryTimeout(int timeout) throws SQLException
   {
      try 
      {
         s.setQueryTimeout(timeout);
      }
      catch (SQLException e)
      {
         checkException(e);
      } // end of try-catch
   }

   /**
    *
    * @exception java.sql.SQLException <description>
    */
   public void cancel() throws SQLException
   {
      try 
      {
         s.cancel();
      }
      catch (SQLException e)
      {
         checkException(e);
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @exception java.sql.SQLException <description>
    */
   public void setCursorName(String name) throws SQLException
   {
      try 
      {
         s.setCursorName(name);
      }
      catch (SQLException e)
      {
         checkException(e);
      } // end of try-catch
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public ResultSet getResultSet() throws SQLException
   {
      try 
      {
         return s.getResultSet();
      }
      catch (SQLException e)
      {
         checkException(e);
         return null;
      } // end of try-catch
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int getUpdateCount() throws SQLException
   {
      try 
      {
         return s.getUpdateCount();
      }
      catch (SQLException e)
      {
         checkException(e);
         return 0;
      } // end of try-catch
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public boolean getMoreResults() throws SQLException
   {
      try 
      {
         return s.getMoreResults();
      }
      catch (SQLException e)
      {
         checkException(e);
         return false;
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public boolean getMoreResults(int current) throws SQLException
   {
@JDK1.4START@
      try 
      {
         return s.getMoreResults(current);
      }
      catch (SQLException e)
      {
         checkException(e);
         return false;
      } // end of try-catch
@JDK1.4END@
@JDK1.3START@
   throw new SQLException("JDK1.4 method not available in JDK1.3");
@JDK1.3END@
   }

   /**
    *
    * @param param1 <description>
    * @exception java.sql.SQLException <description>
    */
   public void setFetchDirection(int direction) throws SQLException
   {
      try 
      {
         s.setFetchDirection(direction);
      }
      catch (SQLException e)
      {
         checkException(e);
      } // end of try-catch
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int getFetchDirection() throws SQLException
   {
      try 
      {
         return s.getFetchDirection();
      }
      catch (SQLException e)
      {
         checkException(e);
         return 0;
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @exception java.sql.SQLException <description>
    */
   public void setFetchSize(int rows) throws SQLException
   {
      try 
      {
         s.setFetchSize(rows);
      }
      catch (SQLException e)
      {
         checkException(e);
      } // end of try-catch
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int getFetchSize() throws SQLException
   {
      try 
      {
         return s.getFetchSize();
      }
      catch (SQLException e)
      {
         checkException(e);
         return 0;
      } // end of try-catch
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int getResultSetConcurrency() throws SQLException
   {
      try 
      {
         return s.getResultSetConcurrency();
      }
      catch (SQLException e)
      {
         checkException(e);
         return 0;
      } // end of try-catch
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int getResultSetType() throws SQLException
   {
      try 
      {
         return s.getResultSetType();
      }
      catch (SQLException e)
      {
         checkException(e);
         return 0;
      } // end of try-catch
   }

   /**
    *
    * @param param1 <description>
    * @exception java.sql.SQLException <description>
    */
   public void addBatch(String sql) throws SQLException
   {
      try 
      {
         s.addBatch(sql);
      }
      catch (SQLException e)
      {
         checkException(e);
      } // end of try-catch
   }

   /**
    *
    * @exception java.sql.SQLException <description>
    */
   public void clearBatch() throws SQLException
   {
      try 
      {
         s.clearBatch();
      }
      catch (SQLException e)
      {
         checkException(e);
      } // end of try-catch
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int[] executeBatch() throws SQLException
   {
      try 
      {
         return s.executeBatch();
      }
      catch (SQLException e)
      {
         checkException(e);
         return null;
      } // end of try-catch
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public ResultSet getGeneratedKeys() throws SQLException
   {
@JDK1.4START@
      try 
      {
         return s.getGeneratedKeys();
      }
      catch (SQLException e)
      {
         checkException(e);
         return null;
      } // end of try-catch
@JDK1.4END@
@JDK1.3START@
   throw new SQLException("JDK1.4 method not available in JDK1.3");
@JDK1.3END@
   }

   /**
    *
    * @return <description>
    * @exception java.sql.SQLException <description>
    */
   public int getResultSetHoldability() throws SQLException
   {
@JDK1.4START@
      try 
      {
         return s.getResultSetHoldability();
      }
      catch (SQLException e)
      {
         checkException(e);
         return 0;
      } // end of try-catch
@JDK1.4END@
@JDK1.3START@
   throw new SQLException("JDK1.4 method not available in JDK1.3");
@JDK1.3END@
   }

   //Public non-jdbc methods
   public Statement getUnderlyingStatement()
   {
      return s;
   }

   //Protected methods

   protected void checkException(SQLException e)
      throws SQLException
   {
      lc.checkException(e);
   }

   protected void checkTransaction()
      throws SQLException
   {
      lc.checkTransaction();
   }



    //// ROC PINPOINT MIKECHEN EMK BEGIN ////   54 LINES

    static java.util.Map PP_attributes = null;

    protected void reportTrace(String sql, Exception e ) {

	try {
	    if( PP_attributes == null ) {
		PP_attributes = new java.util.HashMap();
		PP_attributes.put( "observationLocation", 
				   "org.jboss.resource.adapter.jdbc.local.LocalPreparedStatement" );
	    }

	    java.util.Map PP_originInfo = new java.util.HashMap( roc.pinpoint.tracing.java.EnvironmentDetails.GetDetails() );
	    PP_originInfo.put( "name", sql );
	    PP_originInfo.put( "type", "sql" );
	    
	    roc.pinpoint.tracing.RequestInfo PP_reqInfo =
		roc.pinpoint.tracing.ThreadedRequestTracer.getRequestInfo();
	    PP_reqInfo.incrementSeqNum();
	
	    roc.pinpoint.tracing.Observation PP_obs =
		new roc.pinpoint.tracing.Observation( roc.pinpoint.tracing.Observation.EVENT_DATABASE_USE,
						      PP_reqInfo,
						      PP_originInfo,
						      null,
						      PP_attributes );
	    roc.pinpoint.tracing.GlobalObservationPublisher.Send( PP_obs );

	    if( e != null ) {
		PP_reqInfo.incrementSeqNum();
		java.util.Map PP_rawDetails = new java.util.HashMap();
		StackTraceElement[] PP_ste = e.getStackTrace();
		java.util.List PP_stacktrace = new java.util.ArrayList( PP_ste.length );
		for( int PP_i=0; PP_i < PP_ste.length; PP_i++ ) {
		    // todo, later, we might want a more structure storage 
		    //       of the details in PP_ste[ PP_i ], rather than
		    //       just a toString() dump.
		    PP_stacktrace.add( PP_ste[ PP_i ].toString() );
		}
		PP_rawDetails.put( "exception", e.toString() );
		PP_rawDetails.put( "stacktrace", PP_stacktrace );
		PP_obs = new roc.pinpoint.tracing.Observation( roc.pinpoint.tracing.Observation.EVENT_ERROR,
							       PP_reqInfo,
							       PP_originInfo,
							       PP_rawDetails,
							       PP_attributes );
		roc.pinpoint.tracing.GlobalObservationPublisher.Send( PP_obs );
	    }
	}
	catch (Exception ex) {
	    ex.printStackTrace();
	}

    }
    //// ROC PINPOINT MIKECHEN EMK END   ////



}// LocalStatement
