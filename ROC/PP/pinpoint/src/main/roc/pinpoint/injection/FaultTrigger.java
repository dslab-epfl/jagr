/**
    Copyright (C) 2004 Emre Kiciman and Stanford University

    This file is part of Pinpoint

    Pinpoint is free software; you can distribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2.1 of the License, or
    (at your option) any later version.

    Pinpoint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Pinpoint; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
**/
package roc.pinpoint.injection;

// marked for release 1.0

import java.util.Set;
import java.util.Map;
import java.util.HashSet;
import java.util.Iterator;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import swig.util.XMLException;
import swig.util.XMLHelper;
import swig.util.XMLStructs;


/**
 * This class describes faults to be injected into a running system,
 * and the triggers for those faults.
 *
 */
public class FaultTrigger {

    public static int FT_NOFAULT = 0;
	public static int FT_THROWEXCEPTION = 1;
    public static int FT_THROWRUNTIMEEXCEPTION = 2;
    public static int FT_INFINITELOOP = 3;
    public static int FT_HALTJVM = 4;
    public static int FT_PERFORMANCE_FAULT_GC = 5;
    // runs in a background thread, for the whole machine!!!
    public static int FT_PERFORMANCE_FAULT_CONSTANT = 6;
    public static int FT_PERFORMANCE_FAULT_CUMULATIVE = 7;
    public static int FT_PERFORMANCE_FAULT_STUTTER = 8;
    public static int FT_PERFORMANCE_FAULT_INTERMITTENT = 9;
    public static int FT_LEAK_MEMORY = 10;

    // marks the boundary between faults generatable by
    // the "FaultTrigger.GenerateFault()" function and those
    // that must be generated by the j2ee-caller.
    protected static int IS_AUTOMATIC_FAULT = 10;

    public static int FT_THROWEXPECTEDEXCEPTION = 11;
    public static int FT_NULLCALL = 12;
    public static int FT_STUCKRESULT = 13;

    public static int MAX_FT = FT_STUCKRESULT;

    public static String[] FAULT_TYPE_STRINGS =
        new String[] {
            "no fault",
            "exception",
            "runtime exception",
            "infinite loop",
            "halt",
            "gcPerformance",
            "constantPerformance",
            "cumulativePerformance",
            "stutterPerformance",
	    "intermittentPerformance",
	    "leakMemory",
            "expected exception",
            "null call",
	    "stuck call" };

    public int faultType;
    public String faultArg;

    public int faultDelay;
    long firsttimechecked;

    Set triggerComponents;
    // a set of component definitions.  if we see any of these components, should trigger a fault.

    public FaultTrigger() {
        faultType = FT_NOFAULT;
	faultArg = null;
        triggerComponents = new HashSet();
    }

    public FaultTrigger(int faultType, String faultArg,
			Set triggerComponents) {
        this.faultType = faultType;
	this.faultArg = faultArg;
        this.triggerComponents = triggerComponents;
    }

    public static int ParseFaultType( String sFaultType ) {
        int ret = -1;
        for (int i = 0; i < FAULT_TYPE_STRINGS.length; i++) {
            if (FAULT_TYPE_STRINGS[i].equals(sFaultType)) {
                ret = i;
                break;
            }
        }

	return ret;
    }
    
    public static FaultTrigger ParseFaultTrigger(Element ftXML)
        throws XMLException {

        FaultTrigger ret = new FaultTrigger();

        String sFaultType = XMLHelper.GetChildText(ftXML, "faulttype");
	ret.faultType = ParseFaultType( sFaultType );

	String sFaultDelay = XMLHelper.GetChildText( ftXML, "faultdelay" );
	if( sFaultDelay != null ) {
	    ret.faultDelay = Integer.parseInt( sFaultDelay );
	}
	else {
	    ret.faultDelay = 0;
	}

        if (ret.faultType == -1) {
            // ACK HUGE ERROR
            //System.err.println( "FaultTrigger.java: [config file error] unrecognized fault type: " + sFaultType );
        }

		ret.faultArg = XMLHelper.GetChildText( ftXML, "faultarg" );

        NodeList nlComponents =
            XMLHelper.GetChildrenByTagName(ftXML, "component");
        for (int i = 0; i < nlComponents.getLength(); i++) {
            Element eComponentMap = (Element)nlComponents.item(i);
            Map componentMap = XMLStructs.ParseMap(eComponentMap, "attr");
            //	    System.err.println( "faulttrigger: read component: " + componentMap );

            ret.triggerComponents.add(componentMap);
        }

        return ret;
    }

    public boolean matches(Map currcomponent) {

        // System.err.println( "faulttrigger: testing " + currcomponent );

        Iterator iter = triggerComponents.iterator();
        while (iter.hasNext()) {
            Map t = (Map)iter.next();
            if (isMapSubset(currcomponent, t)) {

		if( faultDelay > 0 ) {
		    if( firsttimechecked == 0 ) {
			firsttimechecked = System.currentTimeMillis();
		    }

		    if( System.currentTimeMillis() < firsttimechecked + faultDelay ) 
			return false;
		}

                //System.err.println( "faulttrigger: TRIGGER MATCHES!!!!! " + t );
                return true;
            }
            else {
                //System.err.println( "faulttrigger: did NOT match: " + t );
            }
        }

        //System.err.println( "faulttrigger: done testing" );

        return false;
    }

    /**
     * returns true if 'right' is a subset of 'left'
     */
    boolean isMapSubset(Map left, Map right) {
        if (right.size() > left.size()) {
            // can't be a subset
            return false;
        }

        Iterator iter = right.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();
            Object leftValue = left.get(entry.getKey());
            Object rightValue = entry.getValue();
            try {
                if ((leftValue == null && rightValue != null)
                    || (leftValue != null && rightValue == null)
                    || (!leftValue.equals(rightValue))) {
                    return false;
                }
            }
            catch (ClassCastException e) {
                // equals failed
                return false;
            }
        }

        // passed all the tests
        return true;
    }

}
